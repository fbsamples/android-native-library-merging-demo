/*
 * Copyright 2018-present, Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// To be linked into merged libraries.

#define _GNU_SOURCE

#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>

#include <jni.h>

#include "jni_lib_merge.h"
// We define JNI_OnLoad_Weak directly, so this macro doesn't hurt anything,
// but undef it anyway just to avoid possible future confusion.
#undef JNI_OnLoad
#define PRINT(...) JNI_MERGE_PRINT(__VA_ARGS__)

// Class with mapping that will be generated by buck.
static const char* invoke_class_name =
  "com/facebook/soloader/MergedSoMapping$Invoke_JNI_OnLoad";

// Stub pre-merged library to ensure that our custom section gets created
// when we merge a group of native libraries with no JNI_OnLoad.
static struct pre_merge_jni_library pmjl_stub
__attribute__ ((__section__("pre_merge_jni_libraries")))
= {
  .name = "jni_lib_merge-stub",
  .onload_func = NULL,
};

// References to custom section bounds, filled in by linker.
extern struct pre_merge_jni_library __start_pre_merge_jni_libraries;
extern struct pre_merge_jni_library __stop_pre_merge_jni_libraries;


// Returns a malloc'ed string.
static char* method_name_for_invoke(const char* soname) {
  char* name = strdup(soname);
  if (!name) {
    // Can't log here, since we don't know if we're depending on Android logging.
    assert(!"Failed to strdup soname.");
    abort();
  }
  for (char* c = name; *c != '\0'; ++c) {
    if (!isalnum(*c) && *c != '_') {
      *c = '_';
    }
  }
  return name;
}


// Replacement for weak JNI_OnLoad.
jint JNI_OnLoad_Weak(JavaVM* vm, void* reserved) {
  (void)reserved;

  PRINT("Entering merged library JNI_OnLoad.\n");

  // Get the JNI Env so we can register the original JNI_OnLoad methods.
  JNIEnv* env;
  if ((*vm)->GetEnv(vm, (void**)&env, JNI_VERSION_1_2) != JNI_OK) {
    return JNI_ERR;
  }

  // Find the class we need to register with.
  jclass invoke_class = (*env)->FindClass(env, invoke_class_name);
  if (invoke_class == NULL) {
    return JNI_ERR;
  }

  // Construct the argument to RegisterNatives with proper sanitized names
  // and function pointers.
  struct pre_merge_jni_library* start = &__start_pre_merge_jni_libraries;
  struct pre_merge_jni_library* stop = &__stop_pre_merge_jni_libraries;
  size_t num_merged_libraries = stop - start;
  PRINT("Preparing %d pre-merged libs (including stub)\n", num_merged_libraries);
  JNINativeMethod* natives = calloc(num_merged_libraries, sizeof(*natives));
  assert(natives != NULL);
  if (natives == NULL) {
    abort();
  }
  JNINativeMethod* cur_native = natives;
  struct pre_merge_jni_library* pmjl = start;
  for (size_t i = 0; i < num_merged_libraries; i++, pmjl++) {
    if (pmjl == &pmjl_stub) {
      continue;
    }
    char* name = method_name_for_invoke(pmjl->name);
    PRINT("Preparing to register %s.  onload_func: %p\n", name, pmjl->onload_func);

    cur_native->name = name;
    cur_native->signature = "()I";
    cur_native->fnPtr = pmjl->onload_func;
    cur_native++;
  }

  size_t num_actual_methods = cur_native - natives;
  PRINT("About to register %d actual methods.\n", num_actual_methods);
  jint ret = (*env)->RegisterNatives(env, invoke_class, natives, num_actual_methods);

  for (size_t i = 0; i < num_actual_methods; i++) {
    free((void*)natives[i].name);
  }
  free(natives);

  if (ret < 0) {
    // Exception already thrown.
    return JNI_ERR;
  }

  return JNI_VERSION_1_6;
}
